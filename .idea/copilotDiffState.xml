<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/subsystems.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/util/subsystems.java" />
              <option name="originalContent" value="package org.firstinspires.ftc.teamcode.util;&#10;&#10;import static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.hardwareMap;&#10;&#10;import android.service.controls.Control;&#10;&#10;import com.qualcomm.robotcore.hardware.ColorSensor;&#10;import com.qualcomm.robotcore.hardware.DistanceSensor;&#10;import com.qualcomm.robotcore.hardware.HardwareMap;&#10;import com.qualcomm.robotcore.hardware.NormalizedColorSensor;&#10;import com.qualcomm.robotcore.hardware.NormalizedRGBA;&#10;import com.qualcomm.robotcore.hardware.Servo;&#10;&#10;import org.firstinspires.ftc.teamcode.R;&#10;&#10;import java.util.stream.DoubleStream;&#10;&#10;import dev.nextftc.control.ControlSystem;&#10;import dev.nextftc.core.commands.Command;&#10;import dev.nextftc.core.commands.utility.LambdaCommand;&#10;import dev.nextftc.core.components.Component;&#10;import dev.nextftc.core.subsystems.Subsystem;&#10;import dev.nextftc.hardware.controllable.RunToPosition;&#10;import dev.nextftc.hardware.controllable.RunToVelocity;&#10;import dev.nextftc.hardware.impl.CRServoEx;&#10;import dev.nextftc.hardware.impl.MotorEx;&#10;import dev.nextftc.hardware.impl.ServoEx;&#10;import dev.nextftc.hardware.positionable.SetPosition;&#10;import dev.nextftc.hardware.powerable.SetPower;&#10;import kotlin.jvm.internal.Lambda;&#10;&#10;public class subsystems {&#10;&#10;&#10;&#10;//    public static class Indexer implements Subsystem {&#10;//        public static final Indexer INSTANCE = new Indexer();&#10;//        private Indexer() { }&#10;//        private CRServoEx indexer = new CRServoEx(&quot;indexer&quot;);&#10;//        private ServoEx indexengage = new ServoEx(&quot;indexEngage&quot;);&#10;//        private MotorEx intake = new MotorEx(&quot;intake&quot;);&#10;//&#10;//        private int indexerState = 0;&#10;//&#10;//        private boolean isWhite(NormalizedColorSensor sensor){&#10;//            NormalizedRGBA colors = sensor.getNormalizedColors();&#10;//            return colors.red &gt;= 0.04 &amp;&amp; colors.blue &gt;= 0.04 &amp;&amp; colors.green &gt;= 0.04;&#10;//&#10;//        }&#10;//&#10;//        public Command engageindex = new SetPosition(indexengage, 0.825);&#10;//        public Command disengageindex = new SetPosition(indexengage, 0.7);&#10;//        public Command index = new LambdaCommand()&#10;//                .setStart(() -&gt; {&#10;//                    if (isWhite(indexsensor)) {&#10;//                        indexerState = 2;&#10;//                    } else {&#10;//                        indexerState = 4;&#10;//                    }&#10;//&#10;//                })&#10;//                .setUpdate(() -&gt; {&#10;//                    switch (indexerState) {&#10;//                        case 2: // Move until white is no longer detected&#10;//                            if (!isWhite(indexsensor)) {&#10;//                                indexerState = 3;&#10;//                            } else {&#10;//                                indexer.setPower(0.125);&#10;//                                intake.setPower(1);&#10;//                            }&#10;//                            break;&#10;//                        case 3: // Move until the next white is detected&#10;//                            if (isWhite(indexsensor)) {&#10;//                                indexer.setPower(0);&#10;//                                indexerState = 0; // Sequence finished&#10;//                            } else {&#10;//                                indexer.setPower(0.125);&#10;//                                intake.setPower(1);&#10;//                            }&#10;//                            break;&#10;//                        case 4:&#10;//                            if (isWhite(indexsensor)) {&#10;//                                indexer.setPower(0);&#10;//                                indexerState = 0; // Sequence finished&#10;//                            } else {&#10;//                                indexer.setPower(0.125);&#10;//                                intake.setPower(1);&#10;//                            }&#10;//                            break;&#10;//&#10;//                        default: // Idle state&#10;//                            indexer.setPower(0);&#10;//                            break;&#10;//                    }&#10;//                })&#10;//                .setIsDone(() -&gt; true)&#10;//                .requires(this)&#10;//                .setInterruptible(true);&#10;//&#10;//&#10;//        private ControlSystem controlSystem = ControlSystem.builder()&#10;//                .build();&#10;//    }&#10;&#10;    public static class Intake implements Subsystem {&#10;            public static final Intake INSTANCE = new Intake();&#10;&#10;            private Intake(){ }&#10;&#10;            private MotorEx intake = new MotorEx(&quot;intake&quot;);&#10;&#10;            public Command intakeon = new SetPower(intake,-0.4).requires(this);&#10;            public Command intakeoff = new SetPower(intake, 0).requires(this);&#10;    }&#10;    public static class Thrower implements Subsystem {&#10;        public static final Thrower INSTANCE = new Thrower();&#10;&#10;        private Thrower() { }&#10;&#10;        private final MotorEx thrower1 = new MotorEx(&quot;thrower1&quot;);&#10;        private final MotorEx thrower2 = new MotorEx(&quot;thrower2&quot;);&#10;&#10;        private final ControlSystem controlSystem = ControlSystem.builder()&#10;                .velPid(100, 0, 0)&#10;                .armFF(0.000357)&#10;                .build();&#10;&#10;        public Command spinup = new LambdaCommand()&#10;                .setStart(() -&gt; {&#10;                    new RunToVelocity(controlSystem, 800).schedule();&#10;                        }&#10;                )&#10;                .requires(this)&#10;                .setInterruptible(true)&#10;                .setIsDone(() -&gt; true)&#10;                .named(&quot;Spin Thrower Up&quot;);&#10;&#10;        public Command autoshootpos = new LambdaCommand()&#10;                .setStart(() -&gt; {&#10;                    new RunToVelocity(controlSystem, 400, 25).schedule();&#10;                        }&#10;                )&#10;                .requires(this)&#10;                .setInterruptible(true)&#10;                .setIsDone(() -&gt; true)&#10;                .named(&quot;Spin auto thrower&quot;);&#10;&#10;        public Command throwerstart = new LambdaCommand()&#10;                .setStart(() -&gt; {&#10;                    new RunToVelocity(controlSystem, 0);&#10;                })&#10;                .requires(this)&#10;                .setIsDone(() -&gt; true)&#10;                .named(&quot;reset thrower on init&quot;);&#10;&#10;        @Override&#10;        public void periodic() {&#10;            Subsystem.super.periodic();&#10;            double power = controlSystem.calculate(thrower1.getState());&#10;            thrower1.setPower(power);&#10;            thrower2.setPower(power);&#10;        }&#10;&#10;    }&#10;    public static class Lift implements Subsystem {&#10;        public static final Lift INSTANCE = new Lift();&#10;&#10;        private Lift() { }&#10;&#10;        private ServoEx lift = new ServoEx(&quot;lift&quot;);&#10;&#10;        public Command liftup = new SetPosition(lift, 0);&#10;        public Command liftdown = new SetPosition(lift, 0.9);&#10;&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.firstinspires.ftc.teamcode.util;&#10;&#10;import static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.hardwareMap;&#10;&#10;import android.service.controls.Control;&#10;&#10;import com.qualcomm.robotcore.hardware.ColorSensor;&#10;import com.qualcomm.robotcore.hardware.DistanceSensor;&#10;import com.qualcomm.robotcore.hardware.HardwareMap;&#10;import com.qualcomm.robotcore.hardware.NormalizedColorSensor;&#10;import com.qualcomm.robotcore.hardware.NormalizedRGBA;&#10;import com.qualcomm.robotcore.hardware.Servo;&#10;&#10;import org.firstinspires.ftc.teamcode.R;&#10;&#10;import java.util.stream.DoubleStream;&#10;&#10;import dev.nextftc.control.ControlSystem;&#10;import dev.nextftc.core.commands.Command;&#10;import dev.nextftc.core.commands.utility.LambdaCommand;&#10;import dev.nextftc.core.components.Component;&#10;import dev.nextftc.core.subsystems.Subsystem;&#10;import dev.nextftc.hardware.controllable.RunToPosition;&#10;import dev.nextftc.hardware.controllable.RunToVelocity;&#10;import dev.nextftc.hardware.impl.CRServoEx;&#10;import dev.nextftc.hardware.impl.MotorEx;&#10;import dev.nextftc.hardware.impl.ServoEx;&#10;import dev.nextftc.hardware.positionable.SetPosition;&#10;import dev.nextftc.hardware.powerable.SetPower;&#10;import kotlin.jvm.internal.Lambda;&#10;&#10;public class subsystems {&#10;&#10;&#10;&#10;//    public static class Indexer implements Subsystem {&#10;//        public static final Indexer INSTANCE = new Indexer();&#10;//        private Indexer() { }&#10;//        private CRServoEx indexer = new CRServoEx(&quot;indexer&quot;);&#10;//        private ServoEx indexengage = new ServoEx(&quot;indexEngage&quot;);&#10;//        private MotorEx intake = new MotorEx(&quot;intake&quot;);&#10;//&#10;//        private int indexerState = 0;&#10;//&#10;//        private boolean isWhite(NormalizedColorSensor sensor){&#10;//            NormalizedRGBA colors = sensor.getNormalizedColors();&#10;//            return colors.red &gt;= 0.04 &amp;&amp; colors.blue &gt;= 0.04 &amp;&amp; colors.green &gt;= 0.04;&#10;//&#10;//        }&#10;//&#10;//        public Command engageindex = new SetPosition(indexengage, 0.825);&#10;//        public Command disengageindex = new SetPosition(indexengage, 0.7);&#10;//        public Command index = new LambdaCommand()&#10;//                .setStart(() -&gt; {&#10;//                    if (isWhite(indexsensor)) {&#10;//                        indexerState = 2;&#10;//                    } else {&#10;//                        indexerState = 4;&#10;//                    }&#10;//&#10;//                })&#10;//                .setUpdate(() -&gt; {&#10;//                    switch (indexerState) {&#10;//                        case 2: // Move until white is no longer detected&#10;//                            if (!isWhite(indexsensor)) {&#10;//                                indexerState = 3;&#10;//                            } else {&#10;//                                indexer.setPower(0.125);&#10;//                                intake.setPower(1);&#10;//                            }&#10;//                            break;&#10;//                        case 3: // Move until the next white is detected&#10;//                            if (isWhite(indexsensor)) {&#10;//                                indexer.setPower(0);&#10;//                                indexerState = 0; // Sequence finished&#10;//                            } else {&#10;//                                indexer.setPower(0.125);&#10;//                                intake.setPower(1);&#10;//                            }&#10;//                            break;&#10;//                        case 4:&#10;//                            if (isWhite(indexsensor)) {&#10;//                                indexer.setPower(0);&#10;//                                indexerState = 0; // Sequence finished&#10;//                            } else {&#10;//                                indexer.setPower(0.125);&#10;//                                intake.setPower(1);&#10;//                            }&#10;//                            break;&#10;//&#10;//                        default: // Idle state&#10;//                            indexer.setPower(0);&#10;//                            break;&#10;//                    }&#10;//                })&#10;//                .setIsDone(() -&gt; true)&#10;//                .requires(this)&#10;//                .setInterruptible(true);&#10;//&#10;//&#10;//        private ControlSystem controlSystem = ControlSystem.builder()&#10;//                .build();&#10;//    }&#10;&#10;    public static class Intake implements Subsystem {&#10;            public static final Intake INSTANCE = new Intake();&#10;&#10;            private Intake(){ }&#10;&#10;            private MotorEx intake = new MotorEx(&quot;intake&quot;);&#10;&#10;            public Command intakeon = new SetPower(intake,-0.4).requires(this);&#10;            public Command intakeoff = new SetPower(intake, 0).requires(this);&#10;    }&#10;    public static class Thrower implements Subsystem {&#10;        public static final Thrower INSTANCE = new Thrower();&#10;&#10;        private Thrower() { }&#10;&#10;        private final MotorEx thrower1 = new MotorEx(&quot;thrower1&quot;);&#10;        private final MotorEx thrower2 = new MotorEx(&quot;thrower2&quot;);&#10;&#10;        private final ControlSystem controlSystem = ControlSystem.builder()&#10;                .velPid(100, 0, 0)&#10;                .armFF(0.000357)&#10;                .build();&#10;&#10;        public Command spinup = new LambdaCommand()&#10;                .setStart(() -&gt; {&#10;                    new RunToVelocity(controlSystem, 800).schedule();&#10;                        }&#10;                )&#10;                .requires(this)&#10;                .setInterruptible(true)&#10;                .setIsDone(() -&gt; true)&#10;                .named(&quot;Spin Thrower Up&quot;);&#10;&#10;        public Command autoshootpos = new LambdaCommand()&#10;                .setStart(() -&gt; {&#10;                    new RunToVelocity(controlSystem, 400, 25).schedule();&#10;                        }&#10;                )&#10;                .requires(this)&#10;                .setInterruptible(true)&#10;                .setIsDone(() -&gt; true)&#10;                .named(&quot;Spin auto thrower&quot;);&#10;&#10;        public Command throwerstart = new LambdaCommand()&#10;                .setStart(() -&gt; {&#10;                    thrower1.setPower(0);&#10;                    thrower2.setPower(0);&#10;                })&#10;                .requires(this)&#10;                .setIsDone(() -&gt; true)&#10;                .named(&quot;reset thrower on init&quot;);&#10;&#10;        @Override&#10;        public void periodic() {&#10;            Subsystem.super.periodic();&#10;            double power = controlSystem.calculate(thrower1.getState());&#10;            thrower1.setPower(power);&#10;            thrower2.setPower(power);&#10;        }&#10;&#10;    }&#10;    public static class Lift implements Subsystem {&#10;        public static final Lift INSTANCE = new Lift();&#10;&#10;        private Lift() { }&#10;&#10;        private ServoEx lift = new ServoEx(&quot;lift&quot;);&#10;&#10;        public Command liftup = new SetPosition(lift, 0);&#10;        public Command liftdown = new SetPosition(lift, 0.9);&#10;&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>